####################################
# File name: get_traffic.py        #
# Author: Mahmoud Pourmehrab       #
# Email: mpourmehrab@ufl.edu       #
# Last Modified: Feb/16/2018       #
####################################

import os
import pandas as pd
from src.inter.veh import Vehicle
from src.trj.trjopt import Connected
from src.trj.trjest import Conventional


class Traffic:
    ''''
    Goal 1) Input Traffic
        This class reads traffic input from csf file (can be generated by VISSIM or any other)
        the csv file can contain scenarios (refer to the file for headers)
    Goal 2) Append a travel time column and save csv
    Goal 3)
    '''

    def __init__(self, inter_name):
        filepath = os.path.join('data/' + inter_name + '.csv')
        if os.path.exists(filepath):
            self.all_vehicles = pd.read_csv(filepath)
        else:
            raise Exception(filepath + ' was not found.')

        self.all_vehicles.sort_values(['sc', 'arrival time'])

        self.active_sc = self.all_vehicles['sc'].iloc[0]
        # curr_indx points to the last vehicle added (-1 if none has been yet)
        #  note this is cumulative and won't reset after a scenario is done
        self.curr_indx = -1

        # the column to compute the travel time
        self.all_vehicles['departure time'] = 0

    def set_travel_time(self, travel_time, indx):
        self.all_vehicles['departure time'][indx] = travel_time

    def save_csv(self, inter_name):
        filepath = os.path.join('log/' + inter_name + '_results.csv')
        self.all_vehicles.to_csv(filepath, index=False)

    def keep_simulating(self):
        if self.curr_indx == self.all_vehicles.shape[0]:
            return False
        else:
            return True

    def keep_scenario(self):
        indx = self.curr_indx + 1
        if self.all_vehicles['sc'][indx] == self.active_sc:
            return True
        else:
            return False

    def reset_scenario(self):
        indx = self.curr_indx + 1
        self.active_sc = self.all_vehicles['sc'].iloc[indx]

    def get_first_arrival(self):
        cond = self.all_vehicles['sc'] == self.active_sc
        return self.all_vehicles[cond]['arrival time'].iloc[0]

    def update_within_det_range(self, lanes, t, max_speed):
        '''

        :param lanes: vehicles are added to this data structure (dictionary of doubly-linked lists)
        :param t: current simulation clock (sim_ctrl.get_clock() gives access)
        :return:
        '''
        indx = self.curr_indx + 1
        while self.all_vehicles['arrival time'][indx] <= t and self.all_vehicles['sc'][indx] == self.active_sc:
            lane = self.all_vehicles['lane'][indx]
            det_id = 'xyz'  # todo (Patrick) this changes when in real-time mode
            det_type = self.all_vehicles['type'][indx]  # 0: CNV, 1: CAV
            det_time = self.all_vehicles['arrival time'][indx]
            speed = self.all_vehicles['curSpd'][indx]
            dist = self.all_vehicles['dist'][indx]
            des_speed = self.all_vehicles['desSpd'][indx]
            dest = self.all_vehicles['dest'][indx]
            length = self.all_vehicles['L'][indx]
            amin = self.all_vehicles['maxDec'][indx]
            amax = self.all_vehicles['maxAcc'][indx]
            print('*** -> A vehicle of type {:d} detection @ {:2.2f} sec'.format(det_type, det_time))

            # create the vehicle and get the earliest departure time
            veh = Vehicle(det_id, det_type, det_time, speed, dist, des_speed, dest, length, amin, amax, indx)
            # add it
            lanes.vehlist[lane] += [veh]  # recall it is an array

            # compute trajectory to get the earliest departure time
            if det_type == 1:  # vehicle is connected
                if len(lanes.vehlist[lane]) == 1:  # case 1: lead vehicle
                    # Case 1: lead connected vehicle
                    #  happens when a connected vehicle is the first in the lane
                    trj_planner = Connected(None, veh, vmax=max_speed)
                    trj_planner.insight()  # optional: if want to print some overview of follower vehicle
                    trj_planner.solve_earlst(0)  # pass 0 for lead vehicle
                else:  # case 2: follower vehicle
                    # Case 2: follower connected vehicle
                    # happens when a connected vehicle is NOT the first in the lane
                    trj_planner = Connected(lanes.vehlist[-2], veh, vmax=max_speed)
                    trj_planner.solve_earlst(1)  # pass 1 for follower vehicle (when first argument is not None)
            else:  # type is 1 meaning vehicle is conventional
                if len(lanes.vehlist[lane]) == 1:  # case 3: lead vehicle
                    # Case 3: lead conventional vehicle
                    # happens when a conventional vehicle is the first in the lane
                    trj_planner = Conventional(None, veh)
                    trj_planner.solve(0)  # pass 0 for lead vehicle
                else:  # case 4: follower vehicle
                    # Case 4: lead conventional vehicle
                    # happens when a conventional vehicle is NOT the first in the lane
                    trj_planner = Conventional(lanes.vehlist[-2], veh)
                    trj_planner.solve(1)  # pass 1 for follower vehicle (when first argument is not None)

            # now that we have a trj, we can set the earliest departure time
            veh.set_earlst()

            indx += 1

        # to keep track of how much of csv is processed
        self.curr_indx = indx - 1

    def update_at_stop_bar(self, lanes, t, num_lanes):

        for lane in range(num_lanes):

            if bool(lanes.vehlist[lane]):  # not an empty lane

                veh_indx, upper_veh_indx = 0, len(lanes.vehlist[lane])
                any_veh_served = False
                while veh_indx < upper_veh_indx:

                    trj_indx = lanes.vehlist[lane][veh_indx].last_trj_point_indx
                    dep_time = lanes.vehlist[lane][veh_indx].trajectory[trj_indx, 0]
                    if dep_time <= t:  # served
                        any_veh_served = True
                        self.set_travel_time(dep_time, lanes.vehlist[lane].csv_indx)
                        veh_indx += 1
                    else:
                        break

                if any_veh_served:  # remove them
                    lanes.purge_served_vehs(lane, veh_indx)
