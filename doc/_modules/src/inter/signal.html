
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>src.inter.signal &#8212; AVIAN 1.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../ReadMe.html">AVIAN 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for src.inter.signal</h1><div class="highlight"><pre>
<span></span><span class="c1">####################################</span>
<span class="c1"># File name: signal.py             #</span>
<span class="c1"># Author: Mahmoud Pourmehrab       #</span>
<span class="c1"># Email: mpourmehrab@ufl.edu       #</span>
<span class="c1"># Last Modified: Apr/24/2018       #</span>
<span class="c1">####################################</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2018</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">data.data</span> <span class="k">as</span> <span class="nn">data_importer</span>


<div class="viewcode-block" id="Signal"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal">[docs]</a><span class="k">class</span> <span class="nc">Signal</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class serves the following goals:</span>
<span class="sd">        - Keeps the SPaT decision updated</span>
<span class="sd">        - Makes SPaT decisions through variety of control methods. For now it supports:</span>
<span class="sd">            - Pre-timed control</span>
<span class="sd">            - Genetic Algorithm</span>
<span class="sd">            - Min Cost Flow model</span>

<span class="sd">    Set the class variable ``LAG`` to the time (in seconds) that from start of green is not valid to schedule any</span>
<span class="sd">    departurs.</span>
<span class="sd">.. note::</span>
<span class="sd">    - ``LAG`` also is used in ``Trajectory()`` class. Set them consistent.</span>
<span class="sd">    - ``LARGE_NUM`` is a large number to initialize badness of alternatives in GA.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LAG</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">LARGE_NUM</span> <span class="o">=</span> <span class="mi">999999</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">min_headway</span><span class="p">,</span> <span class="n">print_signal_detail</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elements:</span>
<span class="sd">            - sequence keeps the sequence of phases to be executed from 0</span>
<span class="sd">            - green_dur keeps the amount of green allocated to each phase</span>
<span class="sd">            - yellow and all-red is a fix amount at the end of all phases (look at class variables)</span>
<span class="sd">            - start keeps the absolute time (in seconds) when each phase starts</span>

<span class="sd">        Note: SPaT starts executing from index 0 to end of each list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inter_name</span> <span class="o">=</span> <span class="n">inter_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_lanes</span> <span class="o">=</span> <span class="n">num_lanes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_min_headway</span> <span class="o">=</span> <span class="n">min_headway</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_lane_lane_incidence</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_phase_lane_incidence</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span> <span class="o">=</span> <span class="n">print_signal_detail</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="Signal._set_lane_lane_incidence"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal._set_lane_lane_incidence">[docs]</a>    <span class="k">def</span> <span class="nf">_set_lane_lane_incidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This converts a dictionary of the form:</span>
<span class="sd">        key is a lane and value is *set* of lanes that are in conflict with key (note numbering starts from 1 not 0)</span>
<span class="sd">        to ``lane_lane_incidence`` which includes the conflict matrix :math:`|L|*|L|` where element :math:`ij`</span>
<span class="sd">        is 1 if :math:`i` and :math:`j` are</span>
<span class="sd">        conflicting movements</span>

<span class="sd">        :param num_lanes:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># gets the conflict dictionary for this intersection</span>
        <span class="n">conf_dict</span> <span class="o">=</span> <span class="n">data_importer</span><span class="o">.</span><span class="n">get_conflict_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inter_name</span><span class="p">)</span>

        <span class="c1"># lane-lane incidence dictionary (lane: set of lanes in conflict with lane)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lane_lane_incidence</span> <span class="o">=</span> <span class="p">{</span><span class="n">l</span><span class="p">:</span> <span class="nb">set</span><span class="p">([])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)}</span>

        <span class="c1"># the whole following loop makes lanes zero-based</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">conf_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lane_lane_incidence</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># these are conflicting lanes</span></div>

<div class="viewcode-block" id="Signal._set_phase_lane_incidence"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal._set_phase_lane_incidence">[docs]</a>    <span class="k">def</span> <span class="nf">_set_phase_lane_incidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the phase-phase incidence matrix of the intersection</span>
<span class="sd">        #todo automate phase enumerator</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_lane_incidence_one_based</span> <span class="o">=</span> <span class="n">data_importer</span><span class="o">.</span><span class="n">get_phases</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inter_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phase_lane_incidence_one_based</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># todo add this to the readme</span>
            <span class="n">phase_lane_incidence_one_based</span> <span class="o">=</span> <span class="n">phase_enumerator</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lane_lane_incidence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inter_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pli</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phase_lane_incidence_one_based</span><span class="p">))}</span>

        <span class="c1"># the whole following loop makes lanes and phases zero-based</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">phase_lane_incidence_one_based</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pli</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># these are lanes that belong to this phase</span></div>

<div class="viewcode-block" id="Signal.append_extend_phase"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal.append_extend_phase">[docs]</a>    <span class="k">def</span> <span class="nf">append_extend_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">actual_green</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a phase to the SPaT (append a phase and its green to the end of signal array)</span>
<span class="sd">        Note SPaT decision is the sequence and green duration of phases</span>

<span class="sd">        :param phase: phase to be added</span>
<span class="sd">        :param actual_green: green duration of that phase</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">phase</span><span class="p">:</span>  <span class="c1"># extend this phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">actual_green</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;-&gt; Phase </span><span class="si">{:d}</span><span class="s1"> Extended (ends @ </span><span class="si">{:&gt;2.1f}</span><span class="s1"> sec) &gt;-&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># append a new phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span> <span class="o">+=</span> <span class="p">[</span><span class="n">phase</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span> <span class="o">+=</span> <span class="p">[</span><span class="n">actual_green</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">actual_green</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;&gt;&gt; Phase </span><span class="si">{:d}</span><span class="s1"> appended (ends @ </span><span class="si">{:&gt;2.1f}</span><span class="s1"> sec)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Signal.set_critical_phase_volumes"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal.set_critical_phase_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">set_critical_phase_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volumes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not used in GA since the phasing configuration is unknown prior to cycle length formula</span>
<span class="sd">        that is derived from time budget concept</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Do not call this on a signal method that does not take ``allowable_phases`` as input</span>

<span class="sd">        :param volumes:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_critical_phase_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pli</span><span class="p">[</span><span class="n">phase</span><span class="p">]])</span> <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowable_phases</span><span class="p">])</span></div>

<div class="viewcode-block" id="Signal.update_SPaT"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal.update_SPaT">[docs]</a>    <span class="k">def</span> <span class="nf">update_SPaT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs two tasks to update SPaT based on the given clock:</span>
<span class="sd">            - Removes terminated phase (happens when the all-red is passed)</span>
<span class="sd">            - Checks for  SPaT to not get empty after being updated</span>

<span class="sd">        .. note::</span>
<span class="sd">            - If all phases are getting purged, either make longer SPaT decisions or reduce the simulation steps.</span>

<span class="sd">        :param time_threshold: Normally the current clock of simulation or real-time in :math:`s`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time_threshold</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;If all phases get purged, SPaT becomes empty!&#39;</span><span class="p">)</span>

        <span class="n">phase_indx</span><span class="p">,</span> <span class="n">any_to_be_purged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="n">time_threshold</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="n">phase_indx</span><span class="p">]:</span>
            <span class="n">any_to_be_purged</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">phase_indx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span> <span class="ow">and</span> <span class="n">any_to_be_purged</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;&lt;&lt; Phase(s) &#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[:</span><span class="n">phase_indx</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; expired&#39;</span><span class="p">)</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[:</span><span class="n">phase_indx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span><span class="p">[:</span><span class="n">phase_indx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[:</span><span class="n">phase_indx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[:</span><span class="n">phase_indx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Signal.flush_upcoming_SPaT"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal.flush_upcoming_SPaT">[docs]</a>    <span class="k">def</span> <span class="nf">flush_upcoming_SPaT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just leaves the first SPaT and flushes the rest</span>
<span class="sd">        # todo maybe reduce the green time of first phase too?</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** SPaT Flushed&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.base_badness"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal.base_badness">[docs]</a>    <span class="k">def</span> <span class="nf">base_badness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method aims to serve as many vehicles as possible given the available SPaT. Depending on the signal method,</span>
<span class="sd">         the set of current SPaT could be different. For example:</span>

<span class="sd">            - If called by ``Pretimed()`` solver, the current SPaT may include multiple phases as Pretimed SPaT never</span>
<span class="sd">                gets flushed.</span>
<span class="sd">            - If called by ``GA_SPaT()`` solver, since the SPaT gets flushed before calling. The goal is to serve as</span>
<span class="sd">                many vehicles with only the single current phase in SPaT.</span>

<span class="sd">        The condition to be served is to meet the following criteria:</span>
<span class="sd">            - Respect the minimum headway to the lead vehicle (if present)</span>
<span class="sd">            - Respect the initiation of green plus a lag time specified by LAG as a class variable</span>
<span class="sd">            - Respect the earliest available time at the stop bar controlled by the speed limit  acc/dec rates</span>
<span class="sd">            - Vehicle is allowed to acquire a new trajectory (``veh.redo_trj_allowed`` holds True)</span>

<span class="sd">        The method does not compute or return the badness metric since the it does not aim to change current phase and</span>
<span class="sd">        timing.</span>

<span class="sd">        It may only gets called once per each Signal solve call prior to computation of the new SPaTs.</span>

<span class="sd">        The schedule keeps the earliest departures at the stop bars of each lane and gets updated when a signal decision</span>
<span class="sd">         goes permanent. It is made by a dictionary of arrays (key is lane, value is sorted earliest departures).</span>

<span class="sd">        ``self.first_unsrvd_indx`` and setting the schedule of any possible served vehicles make the main result of this</span>
<span class="sd">        method. The ``self.first_unsrvd_indx`` will be used after this to avoid reserving and double-counting those</span>
<span class="sd">        already served with base SPaT. This also returns ``any_unserved_vehicle`` array that has True if any lane has</span>
<span class="sd">        vehicles that could not be unserved with base SPaT.</span>

<span class="sd">        .. note::</span>
<span class="sd">            - Since base SPaT never gets changed (for safety and practical reasons), any vehicle served by it has to get ``redo_trj_allowed`` value set to ``False``.</span>
<span class="sd">            - It is feasible that if fusion algorithm updates the info on this vehicle and wants an update on trajectory, it rolls back the ``redo_trj_allowed`` to be ``True``. However, this should be decided outside this method.</span>
<span class="sd">            - The reason that this does not return schedule of departures is because they are already set inside this method. Late, the set method skips these.</span>
<span class="sd">            - If a vehicle gets a schedule and has more than one trajectory point, the last index should reset to the first index so when the trajectory is set there would be two points.</span>
<span class="sd">            - all-red from the end and ``LAG`` time from the beginning of a phase are note utilizes by any vehicle.</span>

<span class="sd">        :param lanes:</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :param max_speed:</span>
<span class="sd">        :return: The ``self.first_unsrvd_indx`` array that keeps index off the first unserved vehicle in each lane, is</span>
<span class="sd">        initialized to zero before calling this method and gets updated by the end of this call. It also returns</span>
<span class="sd">        ``served_vehicle_time`` that shows the schedule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">served_vehicle_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">any_unserved_vehicle</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">phase_indx</span><span class="p">,</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">):</span>
            <span class="n">start_green</span><span class="p">,</span> <span class="n">end_yellow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[</span><span class="n">phase_indx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LAG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="n">phase_indx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">any_unserved_vehicle</span><span class="p">):</span>  <span class="c1"># serve all with the current phasing</span>
                <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pli</span><span class="p">[</span><span class="n">phase</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">veh_indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">],</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">veh</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span>

                            <span class="k">if</span> <span class="n">veh</span><span class="o">.</span><span class="n">redo_trj_allowed</span><span class="p">:</span>
                                <span class="n">t_earliest</span> <span class="o">=</span> <span class="n">veh</span><span class="o">.</span><span class="n">earliest_arrival</span>
                                <span class="n">t_scheduled</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_earliest</span><span class="p">,</span> <span class="n">start_green</span><span class="p">,</span> <span class="n">served_vehicle_time</span><span class="p">[</span>
                                    <span class="n">lane</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_headway</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">t_scheduled</span> <span class="o">&lt;</span> <span class="n">end_yellow</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="n">veh</span><span class="o">.</span><span class="n">last_trj_point_indx</span> <span class="o">=</span> <span class="n">veh</span><span class="o">.</span><span class="n">first_trj_point_indx</span>
                                    <span class="n">veh</span><span class="o">.</span><span class="n">set_scheduled_arrival</span><span class="p">(</span><span class="n">t_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">,</span> <span class="n">lane</span><span class="p">,</span> <span class="n">veh_indx</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">)</span>  <span class="c1"># since this is final</span>
                                    <span class="n">served_vehicle_time</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_scheduled</span>
                                    <span class="n">veh</span><span class="o">.</span><span class="n">redo_trj_allowed</span> <span class="o">=</span> <span class="kc">False</span>

                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">break</span>  <span class="c1"># no more room in this phase (no point to continue)</span>

                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># next vehicle may want trajectory</span>
                                <span class="n">served_vehicle_time</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="n">veh</span><span class="o">.</span><span class="n">scheduled_arrival</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>
                            <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">any_unserved_vehicle</span></div>

<div class="viewcode-block" id="Signal._schedule_unserved_vehicles"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal._schedule_unserved_vehicles">[docs]</a>    <span class="k">def</span> <span class="nf">_schedule_unserved_vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">served_vehicle_time</span><span class="p">,</span> <span class="n">any_unserved_vehicle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sometimes the base SPaT prior to running a ``solve()`` method does not serve all vehicles. However, vehicles</span>
<span class="sd">        require trajectory to be provided. One way to address this is to assign them the best temporal trajectory which</span>
<span class="sd">        only has some of general qualities necessary for continuation of program. In this method we do the followings</span>
<span class="sd">        to compute the ``departure times`` of such trajectories:</span>

<span class="sd">            - Without use of phases, schedule vehicles one after the other at minimum headway restricted by the</span>
<span class="sd">                saturation headway. This gives an overestimate of teh departure time since one vehicle gets served by</span>
<span class="sd">                intersection at a time, while having allowing to depart in phases let multiple simultaneous departures.</span>
<span class="sd">            - This may be called after a signal ``solve()`` method decided to complete those that did not get served.</span>
<span class="sd">            - Also this assumes min headway after green starts instead of ``LAG`` time which is a simplification.</span>
<span class="sd">            - If a vehicle gets a schedule and has more than one trajectory point, the last index should reset to the</span>
<span class="sd">                first index so when the trajectory is set there would be two points.</span>


<span class="sd">        .. warning:: Since the departure times are definitely temporal, DO NOT set ``redo_trj_allowed`` to ``False``.</span>

<span class="sd">        :param lanes:</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :param served_vehicle_time: includes schedule of departures for those served by base SPaT</span>
<span class="sd">        :param any_unserved_vehicle: `Has `False`` for the lane that has all vehicles scheduled through base SPaT and the ``solve()``, ``True`` otherwise.</span>
<span class="sd">        :return: ``served_vehicle_time`` that now includes the schedules of all vehicle except those served through base SPaT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_arrival_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>
                <span class="n">lead_arrival_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">veh_indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">],</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">veh</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span>

                    <span class="n">arrival_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lead_arrival_time</span><span class="p">,</span> <span class="n">max_arrival_time</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_headway</span>
                    <span class="n">max_arrival_time</span> <span class="o">=</span> <span class="n">arrival_time</span>

                    <span class="n">served_vehicle_time</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrival_time</span>
                    <span class="n">veh</span><span class="o">.</span><span class="n">last_trj_point_indx</span> <span class="o">=</span> <span class="n">veh</span><span class="o">.</span><span class="n">first_trj_point_indx</span>
                    <span class="n">veh</span><span class="o">.</span><span class="n">redo_trj_allowed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># just to make sure it&#39;s not False</span>

                <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">served_vehicle_time</span></div>

<div class="viewcode-block" id="Signal._set_non_base_scheduled_arrival"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Signal._set_non_base_scheduled_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">_set_non_base_scheduled_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">scheduled_arrivals</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the scheduled departure in the trajectory of the vehicle.</span>

<span class="sd">        .. note::</span>
<span class="sd">            - Departure schedule of those which were served by base SPaT is set in ``base_badness()`` and not here.</span>

<span class="sd">        :param lanes:</span>
<span class="sd">        :param scheduled_arrivals:</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :param max_speed: by default the departure speed is maximum allowable speed in :math:`m/s`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">veh_indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">],</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">veh</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">veh</span><span class="o">.</span><span class="n">redo_trj_allowed</span><span class="p">:</span>
                    <span class="n">veh</span><span class="o">.</span><span class="n">set_scheduled_arrival</span><span class="p">(</span><span class="n">scheduled_arrivals</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">,</span> <span class="n">lane</span><span class="p">,</span> <span class="n">veh_indx</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span></div></div>


<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># Pre-timed Signal Control</span>
<span class="c1"># -------------------------------------------------------</span>
<div class="viewcode-block" id="Pretimed"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Pretimed">[docs]</a><span class="k">class</span> <span class="nc">Pretimed</span><span class="p">(</span><span class="n">Signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>
<span class="sd">        Assumptions:</span>
<span class="sd">            - The sequence and duration are pre-determined</span>
<span class="sd">            - Cycle length is computed using the time budget concept in traffic flow theory</span>
<span class="sd">                * min and max of 60 and 120 seconds bound the *cycle length*</span>
<span class="sd">    .. warning::</span>
<span class="sd">        Must choose ``NUM_CYCLES`` at least 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_CYCLES</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">min_headway</span><span class="p">,</span> <span class="n">print_signal_detail</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize the pretimed SPaT &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">min_headway</span><span class="p">,</span> <span class="n">print_signal_detail</span><span class="p">)</span>

        <span class="n">pretimed_signal_plan</span> <span class="o">=</span> <span class="n">data_importer</span><span class="o">.</span><span class="n">get_pretimed_parameters</span><span class="p">(</span><span class="n">inter_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span> <span class="o">=</span> <span class="n">pretimed_signal_plan</span><span class="p">[</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_green_dur</span> <span class="o">=</span> <span class="n">pretimed_signal_plan</span><span class="p">[</span><span class="s1">&#39;green_dur&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span> <span class="o">=</span> <span class="n">pretimed_signal_plan</span><span class="p">[</span><span class="s1">&#39;yellow&#39;</span><span class="p">],</span> <span class="n">pretimed_signal_plan</span><span class="p">[</span><span class="s1">&#39;all-red&#39;</span><span class="p">]</span>

        <span class="c1"># add a dummy phase to initiate (note this is the last phase in the sequence to make the order right)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> \
                                                                                  <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_signal_detail</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;&gt;&gt; Phase </span><span class="si">{:d}</span><span class="s1"> appended (ends @ </span><span class="si">{:2.1f}</span><span class="s1"> sec)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NUM_CYCLES</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_extend_phase</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_dur</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>

<div class="viewcode-block" id="Pretimed.solve"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Pretimed.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phases sequence is exactly as the provided in ``data.py``. The flow is:</span>
<span class="sd">            1) First serves using the available SPaT</span>
<span class="sd">            2) This simply adds a cycle to SPaT if a cycle is terminated</span>
<span class="sd">            3) Serves unserved vehicles, if any present</span>
<span class="sd">            4) Next it provides the departure schedule</span>

<span class="sd">        .. note:: The ``scheduled_departures`` is made only to call ``complete_unserved_vehicles()``. It only stores</span>
<span class="sd">                    departures for those vehicles nit served bt base SPaT.</span>

<span class="sd">        :param lanes:</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :param max_speed:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">any_unserved_vehicle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_badness</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_CYCLES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_seq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_extend_phase</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_dur</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">any_unserved_vehicle</span><span class="p">):</span>
            <span class="n">scheduled_departures</span> <span class="o">=</span> <span class="p">{</span><span class="n">lane</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span>
                                    <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)}</span>
            <span class="n">scheduled_departures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schedule_unserved_vehicles</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span>
                                                                    <span class="n">scheduled_departures</span><span class="p">,</span>
                                                                    <span class="n">any_unserved_vehicle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_non_base_scheduled_arrival</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="n">scheduled_departures</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">)</span></div></div>


<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># Genetic Algorithms</span>
<span class="c1"># -------------------------------------------------------</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="k">import</span> <span class="n">SortedDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>


<div class="viewcode-block" id="GA_SPaT"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT">[docs]</a><span class="k">class</span> <span class="nc">GA_SPaT</span><span class="p">(</span><span class="n">Signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assumptions:</span>
<span class="sd">        - The sequence and duration is decided optimally by a Genetic Algorithms</span>
<span class="sd">        - The trajectories are computed using:</span>
<span class="sd">            - Gipps car following model for conventional vehicles</span>
<span class="sd">            - Polynomial degree k area under curve minimization for Lead/Follower AVs</span>

<span class="sd">    :param allowable_phases: subset of all possible phases is used (no limitation but it should cover all movements)</span>
<span class="sd">    .. warning::</span>
<span class="sd">        ``allowable_phases`` should be zero-based unlike what is provided in ``data.py``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># do not include more than this in a phase (is exclusive of last: 1,2, ..., MAX_PHASE_LENGTH-1)</span>
    <span class="n">MAX_PHASE_LENGTH</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">MAX_ITERATION_PER_PHASE</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">CROSSOVER_SIZE</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">ACCURACY_OF_BADNESS_MEASURE</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># this is 10**(number of decimals we want to keep)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">min_headway</span><span class="p">,</span> <span class="n">print_signal_detail</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes GA</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">min_headway</span><span class="p">,</span> <span class="n">print_signal_detail</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_allowable_phases</span> <span class="o">=</span> <span class="n">allowable_phases</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_green</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_green</span> <span class="o">=</span> <span class="n">data_importer</span><span class="o">.</span><span class="n">get_signal_params</span><span class="p">(</span><span class="n">inter_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ts_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_green</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_green</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ts_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_green</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_green</span>

        <span class="c1"># add a dummy phase to initiate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_green_dur</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">allowable_phases</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> \
                                                                                  <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">]</span>
        <span class="c1"># todo print the decision</span>

<div class="viewcode-block" id="GA_SPaT.solve"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">,</span> <span class="n">critical_volume_ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This runs GA</span>
<span class="sd">        the key to the sorted dict is integer part of the travel time times 10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush_upcoming_SPaT</span><span class="p">()</span>  <span class="c1"># todo make sure of the effect</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">any_unserved_vehicle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_badness</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">any_unserved_vehicle</span><span class="p">):</span>  <span class="c1"># if the base SPaT serves, don&#39;t bother doing GA</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(),</span> <span class="s1">&#39;time_split&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(),</span> <span class="s1">&#39;badness_measure&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">LARGE_NUM</span><span class="p">}</span>

            <span class="c1"># correct max phase length in case goes above the range</span>
            <span class="n">max_phase_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allowable_phases</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_PHASE_LENGTH</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">phase_length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_phase_length</span><span class="p">):</span>

                <span class="c1"># this data structure keeps the individuals sorted based on badness level</span>
                <span class="n">population</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">({})</span>

                <span class="n">cycle_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_optimal_cycle_length</span><span class="p">(</span><span class="n">critical_volume_ratio</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">)</span>

                <span class="c1"># population keeps individuals in each row, and:</span>
                <span class="c1">#   - the sequence in the first columns up to the phase size (first block)</span>
                <span class="c1">#   - the timings in the second block of columns</span>
                <span class="c1">#   - the metrics in the third block of columns up to the number of metrics</span>

                <span class="n">half_max_indx</span> <span class="o">=</span> <span class="n">phase_length</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># for crossover</span>

                <span class="c1"># POPULATE THE FIRST GENERATION</span>
                <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POPULATION_SIZE</span><span class="p">):</span>
                    <span class="c1"># set the individuals</span>
                    <span class="n">phase_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutate_seq</span><span class="p">(</span><span class="n">phase_length</span><span class="p">)</span>
                    <span class="n">time_split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutate_timing</span><span class="p">(</span><span class="n">cycle_length</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">)</span>
                    <span class="c1"># evaluate the fitness function</span>
                    <span class="n">badness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_badness</span><span class="p">(</span><span class="n">phase_seq</span><span class="p">,</span> <span class="n">time_split</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">)</span>

                    <span class="n">population</span><span class="p">[</span><span class="n">badness</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">:</span> <span class="n">phase_seq</span><span class="p">,</span> <span class="s1">&#39;time_split&#39;</span><span class="p">:</span> <span class="n">time_split</span><span class="p">}</span>

                <span class="c1"># does GA operations in-place</span>
                <span class="k">if</span> <span class="n">phase_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MAX_ITERATION_PER_PHASE</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CROSSOVER_SIZE</span><span class="p">):</span>
                            <span class="c1"># ELITE SELECTION</span>
                            <span class="c1"># in the next round, the top ones will automatically be removed when crossover</span>
                            <span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="c1"># CROSSOVER</span>
                                <span class="k">del</span> <span class="n">population</span><span class="p">[</span><span class="n">sorted_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># delete the worst member and then add one</span>
                                <span class="n">parents_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sorted_list</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                <span class="n">phase_seq</span><span class="p">,</span> <span class="n">time_split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_over</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="n">parents_indx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                        <span class="n">population</span><span class="p">[</span><span class="n">parents_indx</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                                        <span class="n">phase_length</span><span class="p">,</span> <span class="n">half_max_indx</span><span class="p">)</span>
                                <span class="c1"># evaluate the fitness function</span>
                                <span class="n">badness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_badness</span><span class="p">(</span><span class="n">phase_seq</span><span class="p">,</span> <span class="n">time_split</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">)</span>
                                <span class="n">population</span><span class="p">[</span><span class="n">badness</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">:</span> <span class="n">phase_seq</span><span class="p">,</span> <span class="s1">&#39;time_split&#39;</span><span class="p">:</span> <span class="n">time_split</span><span class="p">}</span>

                <span class="c1"># sorted_list = list(population.keys())</span>
                <span class="c1"># best_temp_indiv = sorted_list[0]</span>

            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_extend_phase</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;time_split&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">any_unserved_vehicle</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_scheduled_arrivals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schedule_unserved_vehicles</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span>
                                                                                <span class="bp">self</span><span class="o">.</span><span class="n">best_scheduled_arrivals</span><span class="p">,</span>
                                                                                <span class="bp">self</span><span class="o">.</span><span class="n">any_unserved_vehicle</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_non_base_scheduled_arrival</span><span class="p">(</span><span class="n">lanes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_scheduled_arrivals</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">max_speed</span><span class="p">)</span></div>

<div class="viewcode-block" id="GA_SPaT.evaluate_badness"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.evaluate_badness">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_badness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase_seq</span><span class="p">,</span> <span class="n">time_split</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param phase_seq:</span>
<span class="sd">        :param time_split:</span>
<span class="sd">        :param lanes:</span>
<span class="sd">        :param num_lanes:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean_travel_time</span><span class="p">,</span> <span class="n">throughput</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># if no vehicle is found return zero throughput</span>
        <span class="n">temporary_scheduled_arrivals</span> <span class="o">=</span> <span class="p">{</span><span class="n">lane</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span>
                                        <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)}</span>

        <span class="c1"># keeps index of last vehicle to be served by progressing SPaT</span>
        <span class="n">served_vehicle_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># keeps index of last vehicle to be served by progressing SPaT</span>
        <span class="n">first_unsrvd_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_unsrvd_indx</span><span class="p">)</span>

        <span class="n">any_unserved_vehicle</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)]</span>

        <span class="n">phase_indx</span><span class="p">,</span> <span class="n">phase_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_seq</span><span class="p">)</span>
        <span class="n">start_green</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LAG</span>
        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">any_unserved_vehicle</span><span class="p">)</span> <span class="ow">and</span> <span class="n">phase_indx</span> <span class="o">&lt;</span> <span class="n">phase_length</span><span class="p">:</span>  <span class="c1"># serve all with the current phasing</span>
            <span class="n">end_yellow</span> <span class="o">=</span> <span class="n">start_green</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">LAG</span> <span class="o">+</span> <span class="n">time_split</span><span class="p">[</span><span class="n">phase_indx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">phase_seq</span><span class="p">[</span><span class="n">phase_indx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pli</span><span class="p">[</span><span class="n">phase</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">veh_indx</span> <span class="o">=</span> <span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span>
                        <span class="n">veh</span> <span class="o">=</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span>

                        <span class="n">t_earliest</span> <span class="o">=</span> <span class="n">veh</span><span class="o">.</span><span class="n">earliest_arrival</span>
                        <span class="c1"># depending on if we are keeping the prev trajectory or not, schedule or reschedule departure</span>
                        <span class="n">t_scheduled</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_earliest</span><span class="p">,</span> <span class="n">start_green</span><span class="p">,</span> <span class="n">served_vehicle_time</span><span class="p">[</span>
                            <span class="n">lane</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_headway</span><span class="p">)</span> <span class="k">if</span> <span class="n">veh</span><span class="o">.</span><span class="n">redo_trj_allowed</span> <span class="k">else</span> <span class="n">veh</span><span class="o">.</span><span class="n">scheduled_arrival</span>

                        <span class="k">if</span> <span class="n">t_scheduled</span> <span class="o">&lt;=</span> <span class="n">end_yellow</span><span class="p">:</span>
                            <span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                            <span class="n">travel_time</span> <span class="o">=</span> <span class="n">t_scheduled</span> <span class="o">-</span> <span class="n">veh</span><span class="o">.</span><span class="n">init_time</span>
                            <span class="n">mean_travel_time</span> <span class="o">=</span> <span class="p">((</span><span class="n">mean_travel_time</span> <span class="o">*</span> <span class="n">throughput</span><span class="p">)</span> <span class="o">+</span> <span class="n">travel_time</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">throughput</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">throughput</span> <span class="o">+=</span> <span class="mi">1</span>

                            <span class="n">served_vehicle_time</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_scheduled</span>
                            <span class="n">temporary_scheduled_arrivals</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_scheduled</span>
                            <span class="k">if</span> <span class="n">first_unsrvd_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lanes</span><span class="o">.</span><span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>
                                <span class="n">any_unserved_vehicle</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>
            <span class="n">phase_indx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">start_green</span> <span class="o">=</span> <span class="n">end_yellow</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span>

        <span class="n">badness</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mean_travel_time</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># this bad individual did not serve any vehicle, penalize it!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;badness_measure&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">badness</span> <span class="ow">and</span> <span class="n">throughput</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># this phase length has the fittest so far</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;badness_measure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">badness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">phase_seq</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_SPaT</span><span class="p">[</span><span class="s1">&#39;time_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">time_split</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">best_scheduled_arrivals</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">temporary_scheduled_arrivals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">any_unserved_vehicle</span> <span class="o">=</span> <span class="n">any_unserved_vehicle</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">mean_travel_time</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span></div>

<div class="viewcode-block" id="GA_SPaT.get_optimal_cycle_length"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.get_optimal_cycle_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_optimal_cycle_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_volume_ratio</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the time budget concept :math:`C=(n*ar)/(1-V_{cr})`.</span>

<span class="sd">        Refer to HCM 2010 for values.</span>

<span class="sd">        :param critical_volume_ratio:</span>
<span class="sd">        :param phase_length:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cycle_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ar</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">critical_volume_ratio</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cycle_length</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">60</span>
        <span class="k">elif</span> <span class="n">cycle_length</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">150</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cycle_length</span></div>

<div class="viewcode-block" id="GA_SPaT.mutate_seq"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.mutate_seq">[docs]</a>    <span class="k">def</span> <span class="nf">mutate_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomize the sequence</span>
<span class="sd">        # todo: if two same phases follow each other, re-sample carefully with replacement</span>

<span class="sd">        :param phase_length:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allowable_phases</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">seq</span></div>

<div class="viewcode-block" id="GA_SPaT.mutate_timing"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.mutate_timing">[docs]</a>    <span class="k">def</span> <span class="nf">mutate_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle_length</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the random phase split</span>
<span class="sd">        Valid timing should respect the min/max green requirement unless it conflicts with the</span>
<span class="sd">        cycle length which in that case we should adjust the maximum green to avoid the slack</span>
<span class="sd">        in time</span>

<span class="sd">        note each timing is between ``g_min+y+ar and g_max+y+ar``</span>

<span class="sd">        :param cycle_length:</span>
<span class="sd">        :param phase_length:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">phase_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cycle_length</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># under worst case all except one phase get minimum green</span>
            <span class="c1">#  check if in that case still we can specify the last phase</span>
            <span class="n">min_G_max</span> <span class="o">=</span> <span class="n">cycle_length</span> <span class="o">-</span> <span class="p">(</span><span class="n">phase_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_min</span>
            <span class="k">if</span> <span class="n">min_G_max</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_max</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_diff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">min_G_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_min</span>

            <span class="c1"># create vector of random numbers drawn from uniform distribution</span>
            <span class="n">rand_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">phase_length</span><span class="p">)</span>
            <span class="c1"># scale it in a way all sum to the cycle length</span>
            <span class="n">rand_vec</span> <span class="o">*=</span> <span class="p">((</span><span class="n">cycle_length</span> <span class="o">-</span> <span class="n">phase_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">rand_vec</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">time_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_ts_min</span> <span class="o">+</span> <span class="n">rand_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase_length</span><span class="p">)],</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">time_split</span><span class="p">)</span></div>

<div class="viewcode-block" id="GA_SPaT.cross_over"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.GA_SPaT.cross_over">[docs]</a>    <span class="k">def</span> <span class="nf">cross_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_parent</span><span class="p">,</span> <span class="n">right_parent</span><span class="p">,</span> <span class="n">phase_length</span><span class="p">,</span> <span class="n">half_max_indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param left_parent:</span>
<span class="sd">        :param right_parent:</span>
<span class="sd">        :param phase_length:</span>
<span class="sd">        :param half_max_indx:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">left_parent</span><span class="p">[</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">half_max_indx</span> <span class="k">else</span> <span class="n">right_parent</span><span class="p">[</span><span class="s1">&#39;phase_seq&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase_length</span><span class="p">)])</span>
        <span class="n">time_split</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">left_parent</span><span class="p">[</span><span class="s1">&#39;time_split&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">right_parent</span><span class="p">[</span><span class="s1">&#39;time_split&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase_length</span><span class="p">)])</span>
        <span class="c1"># todo: if two same phases follow each other, re-sample carefully with replacement</span>
        <span class="k">return</span> <span class="n">phase_seq</span><span class="p">,</span> <span class="n">time_split</span></div></div>


<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># ACTUATED SIGNAL CONTROL</span>
<span class="c1"># -------------------------------------------------------</span>
<div class="viewcode-block" id="ActuatedControl"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.ActuatedControl">[docs]</a><span class="k">class</span> <span class="nc">ActuatedControl</span><span class="p">(</span><span class="n">Signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # todo: main problem is how to schedule the departures</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">)</span></div>


<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># MIN COST FLOW MODEL</span>
<span class="c1"># -------------------------------------------------------</span>

<span class="c1"># from ortools.graph import pywrapgraph</span>
<span class="c1">#</span>
<span class="c1"># todo: replace ortools with CPLEX solver</span>
<span class="c1">#  Example at: https://www.ibm.com/support/knowledgecenter/SSSA5P_12.7.1/ilog.odms.cplex.help/CPLEX/UsrMan/topics/cont_optim/network/05_eg_Interactive_prob_descrip.html#User_manual.uss_solveNet.653116__User_manual.uss_solveNet.657919</span>
<span class="c1"># https://ibmdecisionoptimization.github.io/tutorials/html/Beyond_Linear_Programming.html</span>

<div class="viewcode-block" id="MinCostFlow_SPaT"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.MinCostFlow_SPaT">[docs]</a><span class="k">class</span> <span class="nc">MinCostFlow_SPaT</span><span class="p">(</span><span class="n">Signal</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class is meant to slove the min cost flow problem that is set up for phase selection</span>

<span class="sd">    Code is written in Python 3</span>
<span class="sd">    Install the list of packages in the Pipfile using PyEnv</span>

<span class="sd">    solver by Google: https://goo.gl/jFncvj</span>

<span class="sd">    NODES:</span>
<span class="sd">    Head of phase-selection arcs: from 0 to |p|-1</span>
<span class="sd">    Head of sink arcs: from |p| to 2|p|-1</span>
<span class="sd">    Head of lane-assignment arcs: from 2|p|+1 to 2|p|+|L|</span>

<span class="sd">    ARCS:</span>
<span class="sd">    Phase-selection arcs are from 0 to |p|-1</span>
<span class="sd">        cost 1 unit / cap of M</span>
<span class="sd">    Phase-activator arcs are from |p| to 2|p|-1</span>
<span class="sd">        cost 1 unit / cap of 1</span>
<span class="sd">    Sink arcs are from 2|p| to 3|p|-1</span>
<span class="sd">        cost 0 unit / cap of M</span>
<span class="sd">    Lane-assignment arcs are from 3|p| to len(A)</span>
<span class="sd">        cost 0 unit / cap of M</span>

<span class="sd">    (Note M is the large constant implemented as self.M)</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">M</span> <span class="o">=</span> <span class="mi">999</span>
    <span class="n">CMIN</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">pli</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">)</span>

        <span class="n">num_ph</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pli</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_lanes</span> <span class="o">=</span> <span class="n">num_lanes</span>

        <span class="c1"># to find out relevant nodes</span>

        <span class="c1"># add phase selection arcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_ph</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="c1"># find length od biggest phase</span>
        <span class="n">max_ph_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">pli</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_costs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CMIN</span> <span class="o">+</span> <span class="n">max_ph_size</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pli</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacities</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>

        <span class="c1"># add phase activator arcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">num_ph</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_costs</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CMIN</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacities</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>

        <span class="c1"># add sink arcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">num_ph</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_ph</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_costs</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demand_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_ph</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacities</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ph</span><span class="p">)]</span>

        <span class="c1"># add lane to phase arcs</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">lanes</span> <span class="ow">in</span> <span class="n">pli</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lanes</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_ph</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unit_costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">capacities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">supplies</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_ph</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lanes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

<div class="viewcode-block" id="MinCostFlow_SPaT.set_dem"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.MinCostFlow_SPaT.set_dem">[docs]</a>    <span class="k">def</span> <span class="nf">set_dem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes_demand</span><span class="p">):</span>
        <span class="n">total_dem</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lanes_demand</span><span class="p">):</span>
            <span class="n">total_dem</span> <span class="o">-=</span> <span class="n">d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">supplies</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lanes</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">supplies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lanes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_dem</span></div>

<div class="viewcode-block" id="MinCostFlow_SPaT.solve"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.MinCostFlow_SPaT.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">min_cost_flow</span> <span class="o">=</span> <span class="n">pywrapgraph</span><span class="o">.</span><span class="n">SimpleMinCostFlow</span><span class="p">()</span>

        <span class="c1"># Add each arc.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span><span class="p">)):</span>
            <span class="n">min_cost_flow</span><span class="o">.</span><span class="n">AddArcWithCapacityAndUnitCost</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">capacities</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_costs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Add node supplies.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supplies</span><span class="p">)):</span>
            <span class="n">min_cost_flow</span><span class="o">.</span><span class="n">SetNodeSupply</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supplies</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div></div>

        <span class="c1"># Find the minimum cost flows</span>
        <span class="c1"># if min_cost_flow.Solve() == min_cost_flow.OPTIMAL:</span>
        <span class="c1">#     print(&#39;Minimum cost:&#39;, min_cost_flow.OptimalCost())</span>
        <span class="c1">#     print(&#39;&#39;)</span>
        <span class="c1">#     print(&#39;  Arc    Flow / Capacity  Cost&#39;)</span>
        <span class="c1">#     # for i in range(min_cost_flow.NumArcs()):</span>
        <span class="c1">#     for i in range(16):</span>
        <span class="c1">#         if min_cost_flow.Flow(i) &gt; 0:</span>
        <span class="c1">#             cost = min_cost_flow.Flow(i) * min_cost_flow.UnitCost(i)</span>
        <span class="c1">#             print(&#39;%1s -&gt; %1s   %3s  / %3s       %3s&#39; % (</span>
        <span class="c1">#                 min_cost_flow.Tail(i),</span>
        <span class="c1">#                 min_cost_flow.Head(i),</span>
        <span class="c1">#                 min_cost_flow.Flow(i),</span>
        <span class="c1">#                 min_cost_flow.Capacity(i),</span>
        <span class="c1">#                 cost))</span>
        <span class="c1"># else:</span>
        <span class="c1">#     raise Exception(&#39;There was an issue with the min cost flow input.&#39;)</span>


<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># enumeration</span>
<span class="c1"># -------------------------------------------------------</span>

<div class="viewcode-block" id="Enumerate_SpaT"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Enumerate_SpaT">[docs]</a><span class="k">class</span> <span class="nc">Enumerate_SpaT</span><span class="p">(</span><span class="n">Signal</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Gives all phases equal chance but picks the one with highest throughput</span>
<span class="sd">    Similar to GA functionality</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">)</span>

<div class="viewcode-block" id="Enumerate_SpaT.solve"><a class="viewcode-back" href="../../../[2].intersection.html#src.inter.signal.Enumerate_SpaT.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lanes</span><span class="p">,</span> <span class="n">num_lanes</span><span class="p">,</span> <span class="n">allowable_phases</span><span class="p">):</span>
        <span class="c1"># the goal is to choose the sequence of SPaT which gives more throughput in less time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush_upcoming_SPaT</span><span class="p">()</span>

        <span class="c1"># keeps index of last vehicle to be served by progressing SPaT</span>
        <span class="n">served_vehicle_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">])</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)],</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="c1"># keeps index of last vehicle to be served by progressing SPaT</span>
        <span class="n">last_vehicle_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">all_not_served</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="n">all_not_served</span><span class="p">(</span><span class="n">served_vehicle_indx</span><span class="p">,</span> <span class="n">last_vehicle_indx</span><span class="p">):</span>  <span class="c1"># checks if SPaT did not serve all</span>

            <span class="n">best_phase</span><span class="p">,</span> <span class="n">best_phase_score</span><span class="p">,</span> <span class="n">best_phase_green_dur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">best_throughput</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">allowable_phases</span><span class="p">:</span>  <span class="c1"># gives all phases a chance</span>

                <span class="n">temp_phase_score</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">temp_throughput</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_lanes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

                <span class="c1"># check the length of phase not to exceed the max green</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">phase</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_start</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">time_phase_ends</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_green</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">phase</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPaT_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">lane</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pli</span><span class="p">[</span><span class="n">phase</span><span class="p">]:</span>

                    <span class="n">veh_indx</span> <span class="o">=</span> <span class="n">served_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span>
                    <span class="c1"># check if the lane is not empty and there are vehicles</span>
                    <span class="k">if</span> <span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">veh_indx</span> <span class="o">&lt;=</span> <span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]:</span>

                        <span class="k">while</span> <span class="n">veh_indx</span> <span class="o">&lt;=</span> <span class="n">last_vehicle_indx</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="ow">and</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span>
                            <span class="n">veh_indx</span><span class="p">]</span><span class="o">.</span><span class="n">earlst</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_green</span><span class="p">:</span>
                            <span class="c1"># count and time processing new vehicles</span>
                            <span class="n">temp_throughput</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span><span class="o">.</span><span class="n">earlst</span> <span class="o">&gt;</span> <span class="n">time_phase_ends</span><span class="p">:</span>
                                <span class="n">time_phase_ends</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lanes</span><span class="o">.</span><span class="n">vehlist</span><span class="p">[</span><span class="n">lane</span><span class="p">][</span><span class="n">veh_indx</span><span class="p">]</span><span class="o">.</span><span class="n">earlst</span><span class="p">,</span>
                                                      <span class="n">time_phase_ends</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_headway</span><span class="p">)</span>

                            <span class="n">veh_indx</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># make it permanent if it&#39;s better than previous temporary SPaT</span>
                <span class="n">temp_phase_score</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">time_phase_ends</span> <span class="o">&lt;=</span> <span class="n">start_time</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_throughput</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">time_phase_ends</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">temp_phase_score</span> <span class="o">&gt;</span> <span class="n">best_phase_score</span><span class="p">:</span>
                    <span class="n">best_phase_score</span><span class="p">,</span> <span class="n">best_phase</span> <span class="o">=</span> <span class="n">temp_phase_score</span><span class="p">,</span> <span class="n">phase</span>
                    <span class="n">best_phase_green_dur</span> <span class="o">=</span> <span class="n">time_phase_ends</span> <span class="o">-</span> <span class="n">start_time</span>
                    <span class="n">best_throughput</span> <span class="o">=</span> <span class="n">temp_throughput</span>

            <span class="k">if</span> <span class="n">best_phase_score</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># vehicles are far away, assign a random phase the max green</span>

                <span class="n">remaining_phases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">allowable_phases</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SPaT_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_extend_phase</span><span class="p">(</span><span class="n">remaining_phases</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">max_green</span><span class="p">)</span>  <span class="c1"># pop gives a random phase which is new</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># progress SPaT</span>
                <span class="n">served_vehicle_indx</span> <span class="o">+=</span> <span class="n">best_throughput</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_extend_phase</span><span class="p">(</span><span class="n">best_phase</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_green</span><span class="p">,</span> <span class="n">best_phase_green_dur</span><span class="p">))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../ReadMe.html">AVIAN 1.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Mahmoud Pourmehrab.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>