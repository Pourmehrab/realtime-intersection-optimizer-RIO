#!/usr/bin/python3'''Code is written in Python 3Install the list of packages in the Pipfile using PyEnvBy:     Mahmoud PourmehrabE-mail: mpourmehrab@ufl.eduDate:        Nov 2017Last update: Dec/20/2017'''import os# import datetimeimport sysimport timeimport numpy as npfrom src.inpt.sim import MahmoudSimulatorfrom src.inter.inter import MahmoudIntersectionfrom src.trj.trjopt import MahmoudAVOfrom src.trj.trjest import MahmoudCNVEfrom src.inter.mcfopt import MahmoudSigNetfrom src.inter.veh import MahmoudLanes, MahmoudVehiclefrom src.vis.tikzpans import MahmoudTikZpanels, MahmoudTikzDirectedGraphfrom src.vis.vis import MahmoudVisTrjdef set_CM(inter_name):    filepath = os.path.join('data/' + inter_name, 'CM.txt')    if os.path.exists(filepath):        f = open(filepath, 'w')    else:        f = open(filepath, 'x')    # key is a lane : vals are lanes that are in conflict with key    conf_dict = {1: [7],                 2: [7, 8, 12, 16, 15, 14, 13],                 3: [7, 8, 12, 16, 15, 14, 9],                 4: [7, 16, 8, 15, 9, 11, 10],                 5: [16, 7, 15, 8, 11, 9, 10, 14],                 6: [10],                 7: [10, 15, 11, 16, 5, 4, 3, 2, 1],                 8: [10, 11, 15, 5, 4, 163, 2, 12],                 9: [5, 10, 4, 11, 14, 12, 13, 3],                 10: [13, 14, 4, 5, 9, 8, 7, 6, 15],                 11: [13, 14, 9, 4, 5, 8, 7, 15, 16],                 12: [13, 14, 9, 3, 15, 16, 2, 8],                 13: [2, 3, 9, 12, 11, 10, 4],                 14: [2, 3, 12, 9, 11, 4, 10, 5],                 15: [2, 3, 12, 4, 5, 8, 7, 11, 6],                 16: [12, 2, 3, 8, 4, 7, 5, 11]}    for l1 in range(16):        if 1 in conf_dict[l1 + 1]:            f.write('1')        else:            f.write('0')        for l2 in range(1, 16):            if l2 + 1 in conf_dict[l1 + 1]:                f.write(',1')            else:                f.write(',0')        f.write('\n')    f.close()def MahmoudMainHigh(intersection, num_lanes, ppi, max_speed, signal, lanes, sim_prms):    # do sample signal optimization    lanes_demand = [3, 2, 3, 4, 5, 2, 6, 3, 2, 7, 3, 5, 2, 5, 3, 6]    signal.set_dem(lanes_demand)    signal.solve()    # make min cost flow graph    tikzobj = MahmoudTikzDirectedGraph(inter_name, num_lanes, ppi)    tikzobj.set_mcf_orig()    tikzobj.set_phase_graph()    # Make panels of phases    tikzobj = MahmoudTikZpanels(inter_name, num_lanes, ppi)def MahmoudMainLowDem(intersection, num_lanes, ppi, max_speed, signal, lanes, sim_prms):    # first define what rows of PPI should be used    use_phase = (17, 9, 8, 15)    print('/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\.')    for ph in use_phase:        print('Phase {:d} includes lanes'.format(ph + 1))        for l in range(num_lanes):            if ppi[ph, l]:                print(' ,{:d}'.format(l + 1), end='')        print('\n')    print('/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\.')    # add vehicles to the lane    # work with vehicle data structure    det_time = 0    for i in range(10):        lane = np.random.randint(0, num_lanes)        det_id = 'veh_' + str(np.random.rand())        det_type = np.random.randint(0, 3)        det_time += np.random.exponential(2)  # 2 sec is the saturation headway here        speed = np.random.triangular(0.85 * max_speed, max_speed, 1.1 * max_speed)        dist = np.random.uniform(150 - 10, 150 + 10)  # 150 m is the detection distance        # add vehicle to the list        # lanes.vehlist[lane].add_last(MahmoudVehicle(det_id, det_type, det_time, speed, dist, max_speed))        lanes.vehlist[lane].add_last(MahmoudVehicle(det_id, det_type, 0, 15, 150, 15))        print('A new vehicle detected at lane {:d}, (total of {:d})'.format(lane, len(lanes.vehlist[lane])))        # set earliest travel time for this vehicle        # last.element().set_earlst(det_time + dist / (.85 * max_speed))        # lanes.vehlist[lane].delete(last)        # do some trj optimization        fol_veh = lanes.vehlist[lane].last()  # this would be lead for added vehicle        lead_veh = lanes.vehlist[lane].before(fol_veh)        if lead_veh is None:            # trjoptimizer = MahmoudAVO(None, fol_veh.element(), gs=24, gt=86400, fdeg=0, vmax=15, vcont=10)            trjoptimizer = MahmoudAVO(None, fol_veh.element(), gs=24, gt=86400, fdeg=0, vmax=15, vcont=10)        else:            # trjoptimizer = MahmoudAVO(lead_veh.element(), fol_veh.element(), gs=24, gt=86400, fdeg=0, vmax=15, vcont=10)            trjoptimizer = MahmoudCNVE(lead_veh.element(), fol_veh.element(), gs=24, gt=86400)        # plot = MahmoudVisTrj(lane)  # todo:(Mahmoud) do we need lane information in this file?        # plot.plotrj(fol_veh.element().trj_t, fol_veh.element().trj_d,fol_veh.element().trj_s)if __name__ == "__main__":    print('/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\.\n')    print('Python Path: ', sys.executable)    print('Python Version: ', sys.version)    # Intersection name    inter_name = '13th16th'    # set_CM(inter_name) # Might not be needed (just for 13th and 16th)    # Initialization    intersection = MahmoudIntersection(inter_name)    num_lanes = intersection.get_num_lanes()    ppi = intersection.get_phs()    max_speed = intersection.get_max_speed()  # in m/s    signal = MahmoudSigNet(num_lanes, ppi)    lanes = MahmoudLanes(num_lanes)    sim_prms = MahmoudSimulator(inter_name)    t1 = time.clock()    MahmoudMainLowDem(intersection, num_lanes, ppi, max_speed, signal, lanes, sim_prms)    t2 = time.clock()    print(' Elapsed Time: {} ms'.format(int(1000 * (t2 - t1))), end='')# HOW TO SOLVE LTVO VIA SCIPY# self.bnds = (#     (0, self.vmax), (0, self.vcont), (self.fol_veh.amin, self.fol_veh.amax),#     (self.fol_veh.amin, self.fol_veh.amax))## self.con = (  # const 0: tt greater than equal to gs#     {'type': 'ineq',#      'fun': lambda x, d0, v0, gs_rel:#      np.array((x[3] * (v0 - x[0]) ** 2 + x[2] * (#              2 * x[3] * d0 - (x[0] - x[1]) ** 2))#               / (2 * x[2] * x[3] * x[0]) - gs_rel),#      'jac': self.ttime_der,#      'args': (self.fol_veh.dist, self.fol_veh.speed, self.gs-self.fol_veh.det_time,)},#     # const 1: tt equal to gs#     {'type': 'eq',#      'fun': lambda x, d0, v0, t_opt:#      np.array((x[3] * (v0 - x[0]) ** 2 + x[2] * (#              2 * x[3] * d0 - (x[0] - x[1]) ** 2))#               / (2 * x[2] * x[3] * x[0]) - t_opt),#      'jac': self.ttime_der,#      'args': (self.fol_veh.dist, self.fol_veh.speed, self.tt,)},#     # const 2: t1 >=0#     {'type': 'ineq',#      'fun': lambda x, d0, v0, t_opt:#      np.array((x[0] - v0) / x[2]),#      'jac': lambda x, d0, v0, t_opt:#      np.array([1 / x[2], 0, (v0 - x[0]) / x[2] ** 2, 0]),#      'args': (#          self.fol_veh.dist, self.fol_veh.speed, self.tt,)},#     # const 3: t3 >=0#     {'type': 'ineq',#      'fun': lambda x, d0, v0, t_opt:#      np.array((x[0] - v0) / x[2]),#      'jac': lambda x, d0, v0, t_opt:#      np.array([-1 / x[3], 1 / x[3], 0, (x[1] - x[0]) / x[3] ** 2]),#      'args': (#          self.fol_veh.dist, self.fol_veh.speed, self.tt,)},#     # const 4: t2 >=0#     {'type': 'ineq',#      'fun': lambda x, d0, v0, t_opt:#      np.array((x[0] ** 2 * (x[2] - x[3]) - x[1] ** 2 * x[2] + (v0 ** 2 + 2 * d0 * x[2]) * x[3]) / (#              2 * x[0] * x[2] * x[3])),#      'jac': lambda x, d0, v0, t_opt:#      np.array([((x[0] ** 2 + x[1] ** 2) * x[2] - (v0 ** 2 + x[0] ** 2 + 2 * d0 * x[2]) * x[3]) / (#              2 * x[2] * x[3] * x[0] ** 2), -1 * x[1] / (x[0] * x[3]),#                (x[0] - v0) * (v0 + x[0]) / (2 * x[0] * x[2] ** 2),#                (x[1] ** 2 - x[0] ** 2) / (2 * x[0] * x[3] ** 2)]),#      'args': (#          self.fol_veh.dist, self.fol_veh.speed, self.tt,)},# )# def solve(self):#     '''#     Solves lead vehicle trajectory optimization problem#     '''#     min_travel_time_sol = minimize(self.traveltime,#                                    np.array([self.vmax, self.vcont, self.fol_veh.amax, self.fol_veh.amax]),#                                    args=(self.fol_veh.dist, self.fol_veh.speed, self.gs - self.fol_veh.det_time,),#                                    jac=self.ttime_der, bounds=self.bnds,#                                    constraints=(self.con[k] for k in (0, 2, 3, 4,)), method='SLSQP',#                                    options={'disp': True})#     sol = np.round(np.array([min_travel_time_sol.x[k] for k in (0, 1, 2, 3,)]), 3)##     if self.weakfeasibility(sol):#         if min_travel_time_sol.x[1] < self.vcont - self.EPS:  # see if we can improve discharge speed#             self.tt = min_travel_time_sol.fun##             def depart_spd(x, d0, v0, t_opt):#                 np.array(-1 * x[1])  # since it's minimization##             def depart_spd_der(x, d0, v0, t_opt):#                 np.array([0, -1, 0, 0])##             max_speed_sol = minimize(depart_spd,#                                      min_travel_time_sol.x,#                                      args=(self.fol_veh.dist, self.fol_veh.speed, min_travel_time_sol.fun,),#                                      jac=depart_spd_der, bounds=self.bnds,#                                      constraints=(self.con[k] for k in (1, 2, 3, 4,)), method='SLSQP',#                                      options={'disp': True})#             if self.weakfeasibility(max_speed_sol.x):#                 self.setopt(max_speed_sol.x, max_speed_sol.fun)#             else:#                 self.setopt(min_travel_time_sol.x, min_travel_time_sol.fun)##         else:#             self.setopt(min_travel_time_sol.x, min_travel_time_sol.fun)#     else:#         raise Exception('Review arrival info since trj optimizer is infeasible')